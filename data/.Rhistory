x = v_x[from_patch],
y = v_y[from_patch],
xend = v_x[to_patch],
yend = v_y[to_patch],
edge.id = 1:nrow(df_small),
size = "Small"
)
# Create edge data frames with proper energy flow and coordinates for large edges
edge_data_large <- df_large %>%
mutate(
x = v_x[from_patch],
y = v_y[from_patch],
xend = v_x[to_patch],
yend = v_y[to_patch],
edge.id = 1:nrow(df_large),
size = "Large"
)
# Combine edge data frames
edge_data_combined <- bind_rows(edge_data_small, edge_data_large)
# Calculate edge widths based on the energy flow for small dataset
edge_data_combined$width <- ifelse(edge_data_combined$size == "Small" & edge_data_combined$energy_flow > 0,
(edge_data_combined$energy_flow - min(df_small$energy_flow)) /
(max(df_large$energy_flow) - min(df_small$energy_flow)) * 100,
0)
# Calculate edge widths based on the energy flow for large dataset
edge_data_combined$width <- ifelse(edge_data_combined$size == "Large" & edge_data_combined$energy_flow > 0,
(edge_data_combined$energy_flow - min(df_small$energy_flow)) /
(max(df_large$energy_flow) - min(df_small$energy_flow)) * 100,
edge_data_combined$width)
# Plot for small animal energy flow
p1 <- ggraph(layout, layout = "auto") +
geom_edge_link(
data = edge_data_combined %>% filter(size == "Small" & energy_flow > 0),
aes(width = width),
color = "#a4cc7dff",
lineend = "round",
linejoin = "round",
alpha = 1
) +
geom_node_point(
data = node_data,
aes(x = x, y = y, fill = color),
shape = 21,
size = 15,
color = "grey35"
) +
scale_fill_identity() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.line = element_blank()) +
theme(legend.position = "none") +
labs(title = "")
p1
# Plot for large animal energy flow
p2 <- ggraph(layout, layout = "auto") +
geom_edge_link(
data = edge_data_combined %>% filter(size == "Large" & energy_flow > 0),
aes(width = width),
color = "#264805ff",
lineend = "round",
linejoin = "round",
alpha = 1
) +
geom_node_point(
data = node_data,
aes(x = x, y = y, fill = color),
shape = 21,
size = 15,
color = "grey35"
) +
scale_fill_identity() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.line = element_blank()) +
theme(legend.position = "none") +
labs(title = "")
p2
# Plot for small animal energy flow
p1 <- ggraph(layout, layout = "auto") +
geom_edge_link(
data = edge_data_combined %>% filter(size == "Small" & energy_flow > 0),
aes(width = width),
color = "#a4cc7dff",
lineend = "round",
linejoin = "round",
alpha = 1
) +
geom_node_point(
data = node_data,
aes(x = x, y = y, fill = color),
shape = 21,
size = 15,
color = "grey35"
) +
scale_fill_identity() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.line = element_blank()) +
theme(legend.position = "none") +
labs(title = "")
p1
rm(list=ls())
# Load packages ----------
library("tidyverse")
library("viridis")
library("scales")
# Import dispersal function and empirical data----------
setwd(dirname(getActiveDocumentContext()$path))
source("6-disp-function.R")
setwd('C:/Users/xr49abiw/Documents/Energy-Budget-Model/output')
dispdata <- read.csv("DispersalTransformed.csv")
#   Removing NA, NaN and Inf values
dispdatamax <- dispdata |>
filter(!is.na(Value) & !is.infinite(Value) & !is.nan(Value),
!is.na(Body.mass) & !is.infinite(Body.mass) & !is.nan(Body.mass),
!is.na(Movement.mode) )
#  Filtering for each movement mode
run_max<- dispdatamax|> filter (Movement.mode == "Running")
fly_max <- dispdatamax |> filter (Movement.mode == "Flying")
swim_max <- dispdatamax |> filter (Movement.mode == "Swimming")
# Find unique body mass values from empirical data for each movement mode
body_mass_run <- unique(run_max$Body.mass)
body_mass_fly <- unique(fly_max$Body.mass)
body_mass_swim <- unique(swim_max$Body.mass)
###MODEL PREDICTIONS FOR EACH MOVEMENT MODE####
# Calculate dispersal distances for body masses present in empirical dataset
# Find unique body mass values from empirical data for each movement mode
body_mass_run <- unique(run_max$Body.mass)
body_mass_fly <- unique(fly_max$Body.mass)
body_mass_swim <- unique(swim_max$Body.mass)
# Calculate dispersal predictions for each movement mode and body mass, using disp_fun and unique body mass values
maximum_disp_dist <- function(body_mass, movement_mode) {
maximum_disp_dist <- data.frame()
for (m_C in body_mass) {
disp <- as.data.frame(disp_fun(m_C, movement_mode = movement_mode, lambda = 0.1))
mass_disp <- cbind(m_C, disp)
maximum_disp_dist <- rbind(maximum_disp_dist, mass_disp)
}
return(maximum_disp_dist)
}
# maximum dispersal distance predictions
ds.disprun <- maximum_disp_dist(body_mass_run, "running")
ds.dispfly <- maximum_disp_dist(body_mass_fly, "flying")
ds.dispswim <- maximum_disp_dist(body_mass_swim, "swimming")
rm(list=ls())
# Load packages ----------
library("tidyverse")
library("viridis")
library("scales")
# Import dispersal function and empirical data----------
setwd(dirname(getActiveDocumentContext()$path))
source("6-disp-function.R")
setwd('C:/Users/xr49abiw/Documents/Energy-Budget-Model/output')
dispdata <- read.csv("DispersalTransformed.csv")
#   Removing NA, NaN and Inf values
dispdatamax <- dispdata |>
filter(!is.na(Value) & !is.infinite(Value) & !is.nan(Value),
!is.na(Body.mass) & !is.infinite(Body.mass) & !is.nan(Body.mass),
!is.na(Movement.mode) )
#  Filtering for each movement mode
run_max<- dispdatamax|> filter (Movement.mode == "Running")
fly_max <- dispdatamax |> filter (Movement.mode == "Flying")
swim_max <- dispdatamax |> filter (Movement.mode == "Swimming")
# Find unique body mass values from empirical data for each movement mode
body_mass_run <- unique(run_max$Body.mass)
body_mass_fly <- unique(fly_max$Body.mass)
body_mass_swim <- unique(swim_max$Body.mass)
###MODEL PREDICTIONS FOR EACH MOVEMENT MODE####
# Calculate dispersal distances for body masses present in empirical dataset
# Find unique body mass values from empirical data for each movement mode
body_mass_run <- unique(run_max$Body.mass)
body_mass_fly <- unique(fly_max$Body.mass)
body_mass_swim <- unique(swim_max$Body.mass)
# Calculate dispersal predictions for each movement mode and body mass, using disp_fun and unique body mass values
maximum_disp_dist <- function(body_mass, locomotion_mode) {
maximum_disp_dist <- data.frame()
for (m_C in body_mass) {
disp <- as.data.frame(disp_fun(m_C, locomotion_mode = locomotion_mode, lambda = 0.1))
mass_disp <- cbind(m_C, disp)
maximum_disp_dist <- rbind(maximum_disp_dist, mass_disp)
}
return(maximum_disp_dist)
}
# maximum dispersal distance predictions
ds.disprun <- maximum_disp_dist(body_mass_run, "running")
ds.dispfly <- maximum_disp_dist(body_mass_fly, "flying")
ds.dispswim <- maximum_disp_dist(body_mass_swim, "swimming")
#Rename for plotting
modelmamm <- ds.disprun |>
select(m_C,disp_dist)
modelbird <- ds.dispfly |>
select(m_C,disp_dist)
modelfish<- ds.dispswim |>
select(m_C,disp_dist)
# Model summary for each movement mode
model.disprun <- lm(log10(disp_dist) ~ log10(m_C), data = ds.disprun)
summary(model.disprun)
model.dispfly <- lm(log10(disp_dist) ~ log10(m_C), data = ds.dispfly)
summary(model.dispfly)
model.dispswim <- lm(log10(disp_dist) ~ log10(m_C), data = ds.dispswim)
summary(model.dispswim)
###CALCULATING PERCENTAGE OF DATA ABOVE MODEL PREDICTIONS####
# Left join empirical data with model predictions based on body mass
run_max_merged <- left_join(run_max, ds.disprun, by = c("Body.mass" = "m_C")) %>%
select(gbif.binomial, Value, disp_dist, Body.mass)
fly_max_merged <- left_join(fly_max, ds.dispfly, by = c("Body.mass" = "m_C")) %>%
select(gbif.binomial, Value, disp_dist, Body.mass)
swim_max_merged <- left_join(swim_max, ds.dispswim, by = c("Body.mass" = "m_C")) %>%
select(gbif.binomial, Value, disp_dist, Body.mass)
# calculate the percentage of data points exceeding model predictions
percentage_exceeding <- function(empirical_data, model_predictions) {
exceeding_counts <- sum(empirical_data > model_predictions, na.rm = TRUE)
total_data_points <- sum(!is.na(empirical_data))
percentage_exceeding <- exceeding_counts / total_data_points * 100
return(percentage_exceeding)
}
# for each movement mode
run_max_merged %>%
summarise(percentage_exceeding = percentage_exceeding(Value, disp_dist))
fly_max_merged %>%
summarise(percentage_exceeding = percentage_exceeding(Value, disp_dist))
swim_max_merged %>%
summarise(percentage_exceeding = percentage_exceeding(Value, disp_dist))
###FIGURE 2a-d####
## Plot parameters against body mass
#custom label needed for speed graph
custom_labels <- c(expression(10^2.5), expression(10^3), expression(10^3.5), expression(10^4), expression(10^4.5))
custom_breaks <- c(10^2.5, 10^3, 10^3.5, 10^4, 10^4.5)
vC_plot <- ggplot(ds.disprun, aes(x = m_C, y = v_C)) +
geom_line() +
scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
scale_y_continuous(breaks = custom_breaks, labels = custom_labels, trans = "log10") +
theme_minimal() +
theme( axis.line = element_line(colour = "grey20",size = 1.5, linetype = "solid"))+
geom_line(data = ds.disprun, aes(x = m_C, y = v_C), color = "chartreuse4", linewidth = 1.5) +
geom_line(data = ds.dispfly, aes(x = m_C, y = v_C), color = "red", linewidth = 1.5) +
geom_line(data = ds.dispswim, aes(x = m_C, y = v_C), color = "blue", linewidth = 1.5) +
labs(y = "", x = "") +
theme(
axis.text.x = element_text(size = 35),
axis.text.y = element_text(size = 35),
axis.text = element_text(size = 35),
axis.title = element_text(size = 35),
title = element_text(size = 25, face = "bold"),
legend.position = "none"
)
BMR_plot <- ggplot(ds.disprun, aes(x = m_C, y = BMR, color = viridis(3)[3])) +
geom_line(linewidth = 1.5) +
geom_line(data = ds.dispfly, aes(x = m_C, y = BMR, color = viridis(3)[2]), linewidth = 1.5) +
geom_line(data = ds.dispswim, aes(x = m_C, y = BMR, color = viridis(3)[1]),  linewidth = 1.5) +
scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
scale_color_viridis(discrete = TRUE, option = "D") +
labs(
y = "",
x = "",
color = ""
) +
theme_minimal() +
theme( axis.line = element_line(colour = "grey20",size = 1.5, linetype = "solid"))+
theme(
axis.text.x = element_text(size = 35),
axis.text.y = element_text(size = 35),
axis.text = element_text(size = 35),
axis.title = element_text(size = 35),
title = element_text(size = 25, face = "bold"),
legend.position = "none"
)
COT_plot <- ggplot(ds.disprun, aes(x=m_C, y = COT)) +
geom_line() +
scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
theme_minimal() +
theme( axis.line = element_line(colour = "grey20",size = 1.5, linetype = "solid"))+
geom_line(data = ds.disprun,aes(x=m_C, y = COT),color = "chartreuse4",linewidth=1.5)+
geom_line(data = ds.dispfly,aes(x=m_C, y = COT),color = "red",linewidth=1.5)+
geom_line(data = ds.dispswim,aes(x=m_C, y = COT),color = "blue",linewidth=1.5)+
labs(y= "", x = "")+
theme(
axis.text.x = element_text(size = 35),
axis.text.y = element_text(size = 35),
axis.text = element_text(size = 35),
axis.title = element_text(size = 35),
title = element_text(size = 25, face = "bold"),
legend.position = "none"
)
E0_plot <- ggplot(ds.disprun, aes(x = m_C, y = E_0, color = viridis(3)[3])) +
geom_line( linewidth = 1.5) +
geom_line(data = ds.dispfly, aes(x = m_C, y = E_0, color = viridis(3)[2]), linewidth = 1.5) +
geom_line(data = ds.dispswim, aes(x = m_C, y = E_0, color = viridis(3)[1]), linewidth = 1.5) +
scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
scale_color_viridis(discrete = TRUE, option = "D") +
labs(
y = "",
x = "",
color = "Species"
) +
theme_minimal() +
theme( axis.line = element_line(colour = "grey20",size = 1.5, linetype = "solid"))+
theme(
axis.text.x = element_text(size = 35),
axis.text.y = element_text(size = 35),
axis.text = element_text(size = 35),
axis.title = element_text(size = 35),
title = element_text(size = 25, face = "bold"),
legend.position = "none"
)
vC_plot
BMR_plot
COT_plot
E0_plot
vC_plot <- ggplot(ds.disprun, aes(x = m_C, y = v_C))
vC_plot
# FIGURE 4a-c - The relationship between maximum dispersal distance and body mass for a) flying birds, b) running mammals and c) swimming fish ----------
###Creating plots for each movement mode
#setting colours
mov_colour <- c('Flying' = 'red', 'Swimming' = 'blue', 'Running' = 'palegreen4',
'Model Flying' ='#660000', 'Model Swimming' = '#000066', 'Model Running' = '#003300')
##flying birds
scatter_plot_fly <- fly_max |>
ggplot(aes(x = Body.mass, y = Value, color = Movement.mode)) +
geom_point(size = 2, alpha = 0.2) +
geom_smooth(method = "gam",  linetype = "dashed", se = T, linewidth = 1.5) +
geom_line(data = modelbird, aes(x = m_C, y = disp_dist), linewidth = 1.5, color = mov_colour['Model Flying']) +
labs(x = "", y = "") +
scale_color_manual(name = "Movement Mode", values = mov_colour, guide = "none")+
theme_minimal() +
scale_x_log10(
labels = scales::trans_format("log10", scales::math_format(10^.x)),
breaks = c(1e0, 1e2, 1e4, 1e6),
limits = c(1e0, 1e7)
) +
scale_y_log10(
labels = scales::trans_format("log10", scales::math_format(10^.x)),
breaks = c(1e0, 1e2, 1e4, 1e6, 1e8),
limits = c(1e0, 1e8)
) +
ggtitle("a)")+
theme(axis.line = element_line(colour = "grey20",linewidth = 1.5, linetype = "solid"),
axis.text.x = element_text(size = 35),
axis.text.y = element_text(size = 35),
axis.text = element_text(size = 35),
axis.title = element_text(size = 35),
title = element_text(size = 25, face = "bold"),
legend.position = "none"
)
plot(scatter_plot_fly)
##running mammals
scatter_plot_run <- run_max |>
ggplot(aes(x = Body.mass, y = Value, color = Movement.mode)) +
geom_point(size = 2, alpha = 0.2) +
geom_smooth(method = "gam",linetype = "dashed", se = T,linewidth = 1.5) +
geom_line(data = modelmamm, aes(x = m_C, y = disp_dist), linewidth = 1.5, color = mov_colour['Model Running']) +
labs(x = "", y = "") +
scale_color_manual(name = "Movement Mode", values = mov_colour, guide = "none") +
theme_minimal()  +
scale_x_log10(
labels = scales::trans_format("log10", scales::math_format(10^.x)),
breaks = c(1e0, 1e2, 1e4, 1e6),
limits = c(1e0, 1e7)
) +
scale_y_log10(
labels = scales::trans_format("log10", scales::math_format(10^.x)),
breaks = c(1e0, 1e2, 1e4, 1e6, 1e8),
limits = c(1e0, 1e8)
) +
ggtitle("b)")+
theme(axis.line = element_line(colour = "grey20",linewidth = 1.5, linetype = "solid"),
axis.text.x = element_text(size = 35),
axis.text.y = element_text(size = 35),
axis.text = element_text(size = 35),
axis.title = element_text(size = 35),
title = element_text(size = 25, face = "bold"),
legend.position = "none"
)
plot(scatter_plot_run)
##swimming fish
scatter_plot_swim <- swim_max |>
ggplot(aes(x = Body.mass, y = Value, color = Movement.mode)) +
geom_point(size = 2, alpha = 0.2) +
geom_smooth(method = "gam",linetype = "dashed", se = T,linewidth = 1.5,) +
geom_line(data = modelfish, aes(x = m_C, y = disp_dist), linewidth = 1.5, color = mov_colour['Model Swimming']) +
labs(x = "", y = "") +
scale_color_manual(name = "Movement Mode", values = mov_colour, guide = "none")+
theme_minimal()  +
scale_x_log10(
labels = scales::trans_format("log10", scales::math_format(10^.x)),
breaks = c(1e0, 1e2, 1e4, 1e6),
limits = c(1e0, 1e7)
) +
scale_y_log10(
labels = scales::trans_format("log10", scales::math_format(10^.x)),
breaks = c(1e0, 1e2, 1e4, 1e6, 1e8),
limits = c(1e0, 1e8)
) +
ggtitle("c)")+
theme(axis.line = element_line(colour = "grey20",linewidth = 1.5, linetype = "solid"),
axis.text.x = element_text(size = 35),
axis.text.y = element_text(size = 35),
axis.text = element_text(size = 35),
axis.title = element_text(size = 35),
title = element_text(size = 25, face = "bold"),
legend.position = "none"
)
plot(scatter_plot_swim)
rm(list=ls())
setwd("C:/Users/xr49abiw/Documents/Energy-Budget-Model/data")
# Load all packages ----------
library(tidyverse)
library(rgbif)
# Import trait datasets ----------
db <- read.csv("DispersalUntransformed.csv")|>
filter(Statistic == "Maximum")
# Wilman2014 - EltonTraits
eltonbird<-read_tsv('BirdFuncDat.txt')
eltonmam<-read_tsv('MamFuncDat.txt')
# Boettiger2023 - FishBase
fb <-read_tsv('FishBase.txt')
# Boettiger2023 - SeaLifeBase
slb <-read_tsv('SealifeBase.txt')
# Herberstein2022
anidat<-read_tsv('AnimalTraits.txt')
# 1) Data harmonisation ----------
# extract species names
setdiff(c('a', 'b', 'c'), c('a', 'b')) #find the differences between the the two sets
res <- bind_rows(
db |>
transmute(species = `Species.ID`, db = 'dispdb') |>
distinct_all(),
eltonbird |>
transmute(species = Scientific, db = 'eltonbirds') |>
distinct_all(),
eltonmam |>
transmute(species = Scientific, db = 'eltonmamm') |>
distinct_all(),
fb |>
transmute(species = Species, db = 'FishBase') |>
distinct_all(),
slb |>
transmute(species = Species, db = 'SeaLifeBase') |>
distinct_all(),
anidat |>
transmute(species = species, db = 'AnimalTraits') |>
distinct_all()
)
# Harmonisation using rgbif
checklist <- res |>
mutate(species = gsub('[?]', '', species)) |>
filter(validUTF8(species))
chunksize <- 1e3 #limit is 1e3
res <- as.list(rep(NA, ceiling( nrow(checklist) / chunksize )))
for (i in seq_along(res)) {
### TO DO name_parse, if it fails there are issue with the name, try delete everything after second word.
message(i)
start <- chunksize * (i - 1) + 1
end <- min(start + chunksize - 1, nrow(checklist))
sp <- checklist[["species"]][start:end] #species to check
db <- checklist[["db"]][start:end] #database source to append at the end
first.pass <- name_backbone_checklist(sp) #get taxonomy from gbif
synonyms <- first.pass |>
mutate(status = ifelse(is.na(status), "NOT FOUND", status)) |>
filter(status != 'ACCEPTED') #select only synonyms
keys <- sapply(synonyms[["canonicalName"]], function(x) {
if (is.na(x)) {
return (NA)
} else {
return (name_backbone(x)$usageKey)
}
}, USE.NAMES = FALSE) #get synonyms keys
second.pass <- lapply(keys, function(x) {
if (is.na(x)) {
column_names <- c('key','scientificName','nubKey','nameKey','taxonID','sourceTaxonKey','kingdom','phylum','order','family','genus','species','kingdomKey','phylumKey','classKey','orderKey','familyKey','genusKey','speciesKey','datasetKey','constituentKey','parentKey','parent','acceptedKey','accepted','basionymKey','basionym','canonicalName','vernacularName','authorship','nameType','rank','origin','taxonomicStatus','nomenclaturalStatus','remarks','numDescendants','lastCrawled','lastInterpreted','issues','synonym','class')
ans <- as.list(rep(NA, length(column_names)))
names(ans) <- column_names
ans <- ans |> as_tibble()
return (ans)
} else {
return (name_usage(x)$data) #deeper search of synonyms
}
}) |>
bind_rows() |>
mutate(status = taxonomicStatus,
acceptedUsageKey = key)
# combine back together
second.pass.sp <- first.pass |> #species that go to second.pass
rownames_to_column() |>
mutate(status = ifelse(is.na(status), "NOT FOUND", status)) |>
filter(status != 'ACCEPTED') |>
pull(rowname) |>
as.integer()
stopifnot (length(second.pass.sp) == nrow(second.pass))
res[[i]] <- first.pass |>
mutate(original = sp, db = db) |>
filter(status == "ACCEPTED") |>
bind_rows(second.pass |>
mutate(original = sp[second.pass.sp], db = db[second.pass.sp])) |>
transmute(
db,
original,
gbif.binomial = canonicalName,
gbif.key = usageKey,
rank,
status,
matchType,
phylum,
class,
family,
genus,
species,
)
}
